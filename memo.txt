◈ 컴포넌트 ◈
컴포넌트를 만드는 스크립트가 뷰 인스턴스보다 상단에 있어야한다.

컴포넌트는 중복 사용되는 것을 전제로 한다. (ex. 댓글)
각각의 컴포넌트마다 데이터가 달라야하므로, 
data에서는 항상 새로운 객체를 만들어서 리턴한다

재사용을 위해 사용하지만, 달라지는 부분들은 "props"를 사용하면 된다.

html에서는 kebab-case, 
javascript에서는 camelCase를 사용해도 서로 연결이 된다.

스크립트 파일이 여러개 있을때의 불편함을 webpack이 줄여준다.



◈ 웹팩 ◈
웹팩을 쓰려면 우선 node.js 필요

webpack config 복잡하기 때문에 여러번 보아야 된다!
4개가 중요 -> entry, module(*), plugins, output


main.js
numberBaseball.vue
-> 이렇게 자바스크립트 파일이 2개 있는 것.
-> 이 둘을 합쳐서 dist/app.js로 만들어주어야 html이 완성됨.

-------------------------------------------------------------
노드 환경에서는 require
뷰 환경에서는 import - from

vue, vue-template-compiler 는 같은 버전이어야한다
-------------------------------------------------------------
v-on (=) @
method function e.preventDefault는 디렉토리에서 간단하게 설정가능 = > @.submit.prevent

화면에 보이는 값은 데이터로, 화면에 보이지 않는 값은 변수로 쓰도록!

- babel
bable은 최신 문법 쓸때, 자바스크립트에서 지원하지 않는 문법을 쓸때나
익스플로러같은 오래된 브라우저에서 사용


module - rules에서 .vue 파일은 vue-loader가 해당 파일을 자바스크립트 파일으로 변환해준다

- 자바스크립트의 모듈 시스템
import - from .vue 는
export.default 에 들어간 객체를 의미

- 노드의 모듈 시스템
require
module.exports

--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
[ 반응 속도 체크 강의 ] - 비동기 코드랑 뷰를 같이 써보는 연습

자바스크립트가 아닌 것들은 rules에 loader를 추가해주면 
그 부분을 웹팩이 알아서 자바스크립트로 변환하여 하나의 파일로 만들어준다.

- webpack에서 수정시 다시 빌드할 필요없이 바로 반영되게 설정
package.json - script - "build": "webpack -- watch"
=> 재빌드 없이 수정사항을 반영하지만, 웹페이지에서 새로고침을 해주어야함
=> 새로고침도 필요없도록, npm webpack-dev-server 설치
1. package.json - script에 추가 ("dev": "webpack-dev-server --hot")
2. webpack.config.js - output 추가  (publicPath: '/dist')

- 역할
webpack : 자바스크립트 파일 하나로 만들어줌
module : 모듈은 다른 확장자의 애들을 자바스크립트로 만듬 (웹팩의 대부분의 역할과 관련)
plugin : 부가적인 역할. (ex, 자바스크립트 아웃풋이 나오기 전에 압축해주기)

재사용단위인 컴포넌트마다 스타일이 달라지는데
기본적으로 css는 전역 공유(global) 의 성격이지만 -> 해당 컴포넌트 안에서만 쓰고 싶을때는 스타일태그에 scoped 추가
중복의 실수를 줄이기위해 많이 사용됨

- computed
일반 data를 가공해서 쓸 때 사용
캐싱이 되므로 성능 개선에 도움이 될 수 있음

- v-show와 v-if의 차이
동일하게 화면에는 안 보임.
show : false 이면 style="display:none"이 된다	(눈에만 보이지 않음)
if : false 이면 아예 html태그가 존재하지 않는다	(진짜 없음)

- 감싸준는 용도로 div 쓰기 싫으면, template 쓰면 된다
화면 확인해보면 template 내부 태그들은 하위로 묶이지 않고, 같은 레벨에서 표출됨 (template은 없는 태그)
가장 상위 템플릿의 바로 하위에는 템플릿을 쓸 수 없다

--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
[로또 추첨기] - vue의 라이프 사이클에 대해 중점적으로 배우자

- webpack은 dist/app.js 가 생성되지만 
webpack-dev-server는 실제 파일이 생성되지 않는데도 실행이 잘 된다.
=> webpack-dev-server는 output을 파일로 만들어서 저장하는게 아니라
메모리(가상의 램)에 저장

v-bind:class, v-bind:style
객체 형식을 지원

v-bind:style 의 객체에서
자바스크립트에서는 - 을 빼기로 치므로
자바스크립트에서 css 속성을 표현할때는 - 를 빼고 대문자로 바꿔주세요


화면이 렌더링 되자마자를 알려면, 라이프사이클
created : 컴포넌트가 보여지게 되는 순간 (화면에 나타나기 전)
	템플릿에 데이터 연결하는 작업이 완료된 후. 그러나 자바스크립트 상에서만, 화면은 안 보임
mounted : 데이터를 가지고 실제 화면을 그릴때 (화면에 나타난 후)
	dom ready
updated : (데이터가 바뀌면 화면이 바뀌니까) 이 때 화면이 다시그려질 때
destroyed : 화면에서 사라질때




- ((?)) let과 var
var를 쓰면 생기는 클로저 문제가
let을 쓰면 사라짐

- watch : 어떤 값이 바뀌었는지 감시하는 역할
비동기로 동작하므로, 많아지면 혼동이 올 수 있음
웬만하면 쓰지 않는 것을 추천

computed 새로운 값을 리턴하고
watch 특정 동작을 수행한다


--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
[틱택토] 
오목이 아니라 삼목

test[i][j] = '123'
이렇게 인덱스로 접근해서 값을 바꾸는 것은 반영되지 않는다.
=> (1) Vue.set()
import Vue from 'vue';
Vue.set(this.tableData[1], 0, 'X');
=> (2) this.$set()
this.$set(this.tableData[1], 0, 'X');

* 중요 *
this.$root.$data;
this.$parent.$data;
this.$set (*)
이차원배열
왜 컴포넌트를 잘게잘게 쪼개었는지

최상위 말고 중간 데이터를 수정하다보면..
this.$parent.$parent.$parent.$data;
-> 데이터 파악이 어려움. 가독성 떨어짐.

중앙통제실에서 한 번에 관리를 하면, 거기서 데이터를 가져오면 되잖아
-> 데이터 관리를 위해 Vuex 사용
Vuex를 쓰면 비동기도 깔끔하게 가능
(리덕스 : this.$root.$data와 this.$parent.$data를 지원 안함)

데이터의 중앙 매개체 => Vuex
이벤트의 중앙 매개체 => 이벤트 버스

◈ 이벤트 버스
빈 깡통 뷰를 만들고, $emit과 $on을 이용하여 이벤트를 중앙에서 통제한다.
장점 : 하나의 컴포넌트 모든 이벤트 관리 작업이 가능.
단점 : 이벤트 마다 이벤트 버스에 등록을 해주어야 한다. 이벤트가 많아지면 중앙 코드가 너무 늘어난다.(created, methods)

◈ Vuex
Vuex는 Store를 여러개 만들어도 된다.

state를 바꿀 때, 직접 바꾸지 않고 mutation을 쓰는 이유?
오타내는 실수
일반 문자열은 오타 들어있으면 찾기 힘듬
변수명이 오타가 나는 경우에는 브라우저에서 에러가 나서 바로 알 수 있음

export default / export const A 		((store.js))
export default ---> import store from './store'	((이벤트를 호출하는 .vue))
export const A ---> import { A } from './store'	((이벤트를 호출하는 .vue))